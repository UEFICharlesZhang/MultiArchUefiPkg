From 5abeaeeaa8d81a8d7eb4dee602e4c726d4b3261f Mon Sep 17 00:00:00 2001
From: Andrei Warkentin <andrei.warkentin@intel.com>
Date: Thu, 8 Dec 2022 15:38:53 -0600
Subject: [PATCH 3/4] RISCV: clean up exception handling

RegisterCpuInterruptHandler did not allow setting
exception handlers for anything beyond the timer IRQ.
Beyond that, it didn't meet the spec around handling
of inputs.

RiscVSupervisorModeTrapHandler now will invoke
set handlers for both exceptions and interrupts.
Two arrays of handlers are maintained - one of exceptions
and one for interrupts.

For unhandled traps, RiscVSupervisorModeTrapHandler dumps
state using the now implemented DumpCpuContext.

For EFI_SYSTEM_CONTEXT_RISCV64, extend this with the trapped
PC address (SEPC), just like on AArch64 (ELR). This is
necessary for X86EmulatorPkg to work as it allows a trap
handler to return execution to a different place. Add
SSTATUS as well, at least for debugging purposes. There
is no value in hiding this.

Fix nested exception handling. Handler code should not
be saving SIE (the value is saved in SSTATUS.SPIE) or
directly restored (that's done by SRET). Save and
restore the entire SSTATUS, too.

Signed-off-by: Andrei Warkentin <andrei.warkentin@intel.com>
---
 MdePkg/Include/Protocol/DebugSupport.h        |  22 ++-
 UefiCpuPkg/CpuTimerDxe/RiscV64/Timer.c        |   3 +-
 .../RiscV64/CpuExceptionHandlerLib.c          | 178 +++++++++++++++---
 .../RiscV64/CpuExceptionHandlerLib.h          |   9 +-
 .../RiscV64/SupervisorTrapHandler.S           |  13 +-
 5 files changed, 181 insertions(+), 44 deletions(-)

diff --git a/MdePkg/Include/Protocol/DebugSupport.h b/MdePkg/Include/Protocol/DebugSupport.h
index 2b0ae2d157..e6cc8185ec 100644
--- a/MdePkg/Include/Protocol/DebugSupport.h
+++ b/MdePkg/Include/Protocol/DebugSupport.h
@@ -613,11 +613,25 @@ typedef struct {
 #define EXCEPT_RISCV_STORE_AMO_ACCESS_FAULT        7
 #define EXCEPT_RISCV_ENV_CALL_FROM_UMODE           8
 #define EXCEPT_RISCV_ENV_CALL_FROM_SMODE           9
-#define EXCEPT_RISCV_ENV_CALL_FROM_HMODE           10
+#define EXCEPT_RISCV_10                            10
 #define EXCEPT_RISCV_ENV_CALL_FROM_MMODE           11
+#define EXCEPT_RISCV_INST_ACCESS_PAGE_FAULT        12
+#define EXCEPT_RISCV_LOAD_ACCESS_PAGE_FAULT        13
+#define EXCEPT_RISCV_STORE_ACCESS_PAGE_FAULT       14
+#define EXCEPT_RISCV_MAX_EXCEPTIONS                (EXCEPT_RISCV_STORE_ACCESS_PAGE_FAULT)
 
-#define EXCEPT_RISCV_SOFTWARE_INT  0x0
-#define EXCEPT_RISCV_TIMER_INT     0x1
+///
+/// RISC-V processor exception types for interrupts.
+///
+#define EXCEPT_RISCV_IS_IRQ(x)                     ((x & 0x8000000000000000UL) != 0)
+#define EXCEPT_RISCV_IRQ_INDEX(x)                  (x & 0x7FFFFFFFFFFFFFFFUL)
+#define EXCEPT_RISCV_IRQ_0                         0x8000000000000000UL
+#define EXCEPT_RISCV_IRQ_SOFT_FROM_SMODE           0x8000000000000001UL
+#define EXCEPT_RISCV_IRQ_2                         0x8000000000000002UL
+#define EXCEPT_RISCV_IRQ_SOFT_FROM_MMODE           0x8000000000000003UL
+#define EXCEPT_RISCV_IRQ_4                         0x8000000000000004UL
+#define EXCEPT_RISCV_IRQ_TIMER_FROM_SMODE          0x8000000000000005UL
+#define EXCEPT_RISCV_MAX_IRQS                      (EXCEPT_RISCV_IRQ_INDEX(EXCEPT_RISCV_IRQ_TIMER_FROM_SMODE))
 
 typedef struct {
   UINT64    X0;
@@ -652,6 +666,8 @@ typedef struct {
   UINT64    X29;
   UINT64    X30;
   UINT64    X31;
+  UINT64    SEPC;
+  UINT32    SSTATUS;
 } EFI_SYSTEM_CONTEXT_RISCV64;
 
 //
diff --git a/UefiCpuPkg/CpuTimerDxe/RiscV64/Timer.c b/UefiCpuPkg/CpuTimerDxe/RiscV64/Timer.c
index db153f715e..0ecefddf1f 100644
--- a/UefiCpuPkg/CpuTimerDxe/RiscV64/Timer.c
+++ b/UefiCpuPkg/CpuTimerDxe/RiscV64/Timer.c
@@ -271,7 +271,8 @@ TimerDriverInitialize (
   //
   // Install interrupt handler for RISC-V Timer.
   //
-  Status = mCpu->RegisterInterruptHandler (mCpu, EXCEPT_RISCV_TIMER_INT, TimerInterruptHandler);
+  Status = mCpu->RegisterInterruptHandler (mCpu, EXCEPT_RISCV_IRQ_TIMER_FROM_SMODE,
+                                           TimerInterruptHandler);
   ASSERT_EFI_ERROR (Status);
 
   //
diff --git a/UefiCpuPkg/Library/CpuExceptionHandlerLib/RiscV64/CpuExceptionHandlerLib.c b/UefiCpuPkg/Library/CpuExceptionHandlerLib/RiscV64/CpuExceptionHandlerLib.c
index f1ee7d236a..74e8162629 100644
--- a/UefiCpuPkg/Library/CpuExceptionHandlerLib/RiscV64/CpuExceptionHandlerLib.c
+++ b/UefiCpuPkg/Library/CpuExceptionHandlerLib/RiscV64/CpuExceptionHandlerLib.c
@@ -12,10 +12,113 @@
 #include <Library/DebugLib.h>
 #include <Library/BaseLib.h>
 #include <Register/RiscV64/RiscVEncoding.h>
-
+#include "CpuExceptionLib.h"
 #include "CpuExceptionHandlerLib.h"
 
-STATIC EFI_CPU_INTERRUPT_HANDLER  mInterruptHandlers[2];
+STATIC EFI_CPU_INTERRUPT_HANDLER mExceptionHandlers[EXCEPT_RISCV_MAX_EXCEPTIONS + 1];
+STATIC EFI_CPU_INTERRUPT_HANDLER mIrqHandlers[EXCEPT_RISCV_MAX_IRQS + 1];
+
+STATIC CONST CHAR8 mExceptionOrIrqUnknown[] = "Unknown";
+STATIC CONST CHAR8 *mExceptionNameStr[EXCEPT_RISCV_MAX_EXCEPTIONS + 1] = {
+  "EXCEPT_RISCV_INST_MISALIGNED",
+  "EXCEPT_RISCV_INST_ACCESS_FAULT",
+  "EXCEPT_RISCV_ILLEGAL_INST",
+  "EXCEPT_RISCV_BREAKPOINT",
+  "EXCEPT_RISCV_LOAD_ADDRESS_MISALIGNED",
+  "EXCEPT_RISCV_LOAD_ACCESS_FAULT",
+  "EXCEPT_RISCV_STORE_AMO_ADDRESS_MISALIGNED",
+  "EXCEPT_RISCV_STORE_AMO_ACCESS_FAULT",
+  "EXCEPT_RISCV_ENV_CALL_FROM_UMODE",
+  "EXCEPT_RISCV_ENV_CALL_FROM_SMODE",
+  "EXCEPT_RISCV_ENV_CALL_FROM_HMODE",
+  "EXCEPT_RISCV_ENV_CALL_FROM_MMODE",
+  "EXCEPT_RISCV_INST_ACCESS_PAGE_FAULT",
+  "EXCEPT_RISCV_INST_ACCESS_PAGE_FAULT",
+  "EXCEPT_RISCV_STORE_ACCESS_PAGE_FAULT"
+};
+
+STATIC CONST CHAR8 *mIrqNameStr[EXCEPT_RISCV_MAX_IRQS + 1] = {
+  "EXCEPT_RISCV_IRQ_0",
+  "EXCEPT_RISCV_IRQ_SOFT_FROM_SMODE",
+  "EXCEPT_RISCV_IRQ_2",
+  "EXCEPT_RISCV_IRQ_SOFT_FROM_MMODE",
+  "EXCEPT_RISCV_IRQ_4",
+  "EXCEPT_RISCV_IRQ_TIMER_FROM_SMODE",
+};
+
+/**
+  Get ASCII format string exception name by exception type.
+
+  @param ExceptionType  Exception type.
+
+  @return  ASCII format string exception name.
+**/
+STATIC
+CONST CHAR8 *
+GetExceptionNameStr (
+  IN EFI_EXCEPTION_TYPE  ExceptionType
+  )
+{
+  if (EXCEPT_RISCV_IS_IRQ(ExceptionType)) {
+    if (EXCEPT_RISCV_IRQ_INDEX(ExceptionType) > EXCEPT_RISCV_MAX_IRQS) {
+      return mExceptionOrIrqUnknown;
+    }
+
+    return mIrqNameStr[EXCEPT_RISCV_IRQ_INDEX(ExceptionType)];
+  }
+
+  if (ExceptionType > EXCEPT_RISCV_MAX_EXCEPTIONS) {
+    return mExceptionOrIrqUnknown;
+  }
+
+  return mExceptionNameStr[ExceptionType];
+}
+
+/**
+  Display CPU information.
+
+  @param ExceptionType  Exception type.
+  @param SystemContext  Pointer to EFI_SYSTEM_CONTEXT.
+**/
+VOID
+EFIAPI
+DumpCpuContext (
+  IN EFI_EXCEPTION_TYPE  ExceptionType,
+  IN EFI_SYSTEM_CONTEXT  SystemContext
+  )
+{
+  UINTN Printed = 0;
+  SMODE_TRAP_REGISTERS *Regs = (SMODE_TRAP_REGISTERS *)
+    SystemContext.SystemContextRiscV64;
+
+  InternalPrintMessage (
+    "!!!! RISCV64 Exception Type - %016x(%a) !!!!\n",
+    ExceptionType,
+    GetExceptionNameStr (ExceptionType)
+    );
+
+#define REGS()                                                          \
+  REG (t0); REG (t1); REG (t2); REG (t3); REG (t4); REG (t5); REG (t6); \
+  REG (s0); REG (s1); REG (s2); REG (s3); REG (s4); REG (s5); REG (s6); \
+  REG (s7); REG (s8); REG (s9); REG (s10); REG (s11);                   \
+  REG (a0); REG (a1); REG (a2); REG (a3); REG (a4); REG (a5); REG (a6); \
+  REG (a7);                                                             \
+  REG (zero); REG (ra); REG (sp); REG (gp); REG (tp);                   \
+  REG (sepc); REG (sstatus);
+
+#define REG(x) do {                                         \
+    InternalPrintMessage ("%7a = 0x%017lx%c", #x, Regs->x,  \
+                          (++Printed % 2) ? L'\t' : L'\n'); \
+  } while (0);
+
+  REGS ();
+  if (Printed % 2) {
+    InternalPrintMessage ("\n");
+  }
+
+#undef REG
+#undef REGS
+}
 
 /**
   Initializes all CPU exceptions entries and provides the default exception handlers.
@@ -47,34 +150,56 @@ InitializeCpuExceptionHandlers (
   Registers a function to be called from the processor interrupt handler.
 
   This function registers and enables the handler specified by InterruptHandler for a processor
-  interrupt or exception type specified by InterruptType. If InterruptHandler is NULL, then the
-  handler for the processor interrupt or exception type specified by InterruptType is uninstalled.
+  interrupt or exception type specified by ExceptionType. If InterruptHandler is NULL, then the
+  handler for the processor interrupt or exception type specified by ExceptionType is uninstalled.
   The installed handler is called once for each processor interrupt or exception.
   NOTE: This function should be invoked after InitializeCpuExceptionHandlers() or
   InitializeCpuInterruptHandlers() invoked, otherwise EFI_UNSUPPORTED returned.
 
-  @param[in]  InterruptType     Defines which interrupt or exception to hook.
+  @param[in]  ExceptionType     Defines which interrupt or exception to hook.
   @param[in]  InterruptHandler  A pointer to a function of type EFI_CPU_INTERRUPT_HANDLER that is called
                                 when a processor interrupt occurs. If this parameter is NULL, then the handler
                                 will be uninstalled.
 
   @retval EFI_SUCCESS           The handler for the processor interrupt was successfully installed or uninstalled.
-  @retval EFI_ALREADY_STARTED   InterruptHandler is not NULL, and a handler for InterruptType was
+  @retval EFI_ALREADY_STARTED   InterruptHandler is not NULL, and a handler for ExceptionType was
                                 previously installed.
-  @retval EFI_INVALID_PARAMETER InterruptHandler is NULL, and a handler for InterruptType was not
+  @retval EFI_INVALID_PARAMETER InterruptHandler is NULL, and a handler for ExceptionType was not
                                 previously installed.
-  @retval EFI_UNSUPPORTED       The interrupt specified by InterruptType is not supported,
+  @retval EFI_UNSUPPORTED       The interrupt specified by ExceptionType is not supported,
                                 or this function is not supported.
 **/
 EFI_STATUS
 EFIAPI
 RegisterCpuInterruptHandler (
-  IN EFI_EXCEPTION_TYPE         InterruptType,
+  IN EFI_EXCEPTION_TYPE         ExceptionType,
   IN EFI_CPU_INTERRUPT_HANDLER  InterruptHandler
   )
 {
-  DEBUG ((DEBUG_INFO, "%a: Type:%x Handler: %x\n", __FUNCTION__, InterruptType, InterruptHandler));
-  mInterruptHandlers[InterruptType] = InterruptHandler;
+  DEBUG ((DEBUG_INFO, "%a: Type:%x Handler: %x\n", __FUNCTION__, ExceptionType, InterruptHandler));
+  if (EXCEPT_RISCV_IS_IRQ(ExceptionType)) {
+    if (EXCEPT_RISCV_IRQ_INDEX(ExceptionType) > EXCEPT_RISCV_MAX_IRQS) {
+      return EFI_UNSUPPORTED;
+    }
+
+    if (mIrqHandlers[EXCEPT_RISCV_IRQ_INDEX(ExceptionType)] != NULL) {
+      return EFI_ALREADY_STARTED;
+    } else if (InterruptHandler == NULL) {
+      return EFI_INVALID_PARAMETER;
+    }
+    mIrqHandlers[EXCEPT_RISCV_IRQ_INDEX(ExceptionType)] = InterruptHandler;
+  } else {
+    if (ExceptionType > EXCEPT_RISCV_MAX_EXCEPTIONS) {
+      return EFI_UNSUPPORTED;
+    }
+
+    if (mExceptionHandlers[ExceptionType] != NULL) {
+      return EFI_ALREADY_STARTED;
+    } else if (InterruptHandler == NULL) {
+      return EFI_INVALID_PARAMETER;
+    }
+    mExceptionHandlers[ExceptionType] = InterruptHandler;
+  }
   return EFI_SUCCESS;
 }
 
@@ -113,21 +238,28 @@ RiscVSupervisorModeTrapHandler (
   SMODE_TRAP_REGISTERS  *SmodeTrapReg
   )
 {
-  UINTN               SCause;
+  EFI_EXCEPTION_TYPE  ExceptionType;
   EFI_SYSTEM_CONTEXT  RiscVSystemContext;
 
   RiscVSystemContext.SystemContextRiscV64 = (EFI_SYSTEM_CONTEXT_RISCV64 *)SmodeTrapReg;
-  //
-  // Check scasue register.
-  //
-  SCause = (UINTN)RiscVGetSupervisorTrapCause ();
-  if ((SCause & (1UL << (sizeof (UINTN) * 8- 1))) != 0) {
-    //
-    // This is interrupt event.
-    //
-    SCause &= ~(1UL << (sizeof (UINTN) * 8- 1));
-    if ((SCause == IRQ_S_TIMER) && (mInterruptHandlers[EXCEPT_RISCV_TIMER_INT] != NULL)) {
-      mInterruptHandlers[EXCEPT_RISCV_TIMER_INT](EXCEPT_RISCV_TIMER_INT, RiscVSystemContext);
+  ExceptionType = (UINTN)RiscVGetSupervisorTrapCause ();
+
+  if (EXCEPT_RISCV_IS_IRQ(ExceptionType)) {
+    UINTN IrqIndex = EXCEPT_RISCV_IRQ_INDEX(ExceptionType);
+
+    if (IrqIndex <= EXCEPT_RISCV_MAX_IRQS &&
+        mIrqHandlers[IrqIndex] != NULL) {
+      mIrqHandlers[IrqIndex] (ExceptionType, RiscVSystemContext);
+      return;
+    }
+  } else {
+    if (ExceptionType <= EXCEPT_RISCV_MAX_EXCEPTIONS &&
+        mExceptionHandlers[ExceptionType] != 0) {
+      mExceptionHandlers[ExceptionType] (ExceptionType, RiscVSystemContext);
+      return;
     }
   }
+
+  DumpCpuContext (ExceptionType, RiscVSystemContext);
+  while (1);
 }
diff --git a/UefiCpuPkg/Library/CpuExceptionHandlerLib/RiscV64/CpuExceptionHandlerLib.h b/UefiCpuPkg/Library/CpuExceptionHandlerLib/RiscV64/CpuExceptionHandlerLib.h
index 30f47e8755..c9acee76f6 100644
--- a/UefiCpuPkg/Library/CpuExceptionHandlerLib/RiscV64/CpuExceptionHandlerLib.h
+++ b/UefiCpuPkg/Library/CpuExceptionHandlerLib/RiscV64/CpuExceptionHandlerLib.h
@@ -59,7 +59,6 @@ SupervisorModeTrap (
 #define SMODE_TRAP_REGS_t6       31
 #define SMODE_TRAP_REGS_sepc     32
 #define SMODE_TRAP_REGS_sstatus  33
-#define SMODE_TRAP_REGS_sie      34
 #define SMODE_TRAP_REGS_last     35
 
 #define SMODE_TRAP_REGS_OFFSET(x)  ((SMODE_TRAP_REGS_##x) * __SIZEOF_POINTER__)
@@ -68,7 +67,7 @@ SupervisorModeTrap (
 #pragma pack(1)
 typedef struct {
   //
-  // Below are follow the format of EFI_SYSTEM_CONTEXT
+  // Below follow the format of EFI_SYSTEM_CONTEXT.
   //
   UINT64    zero;
   UINT64    ra;
@@ -102,14 +101,8 @@ typedef struct {
   UINT64    t4;
   UINT64    t5;
   UINT64    t6;
-  //
-  // Below are the additional information to
-  // EFI_SYSTEM_CONTEXT, private to supervisor mode trap
-  // and not public to EFI environment.
-  //
   UINT64    sepc;
   UINT64    sstatus;
-  UINT64    sie;
 } SMODE_TRAP_REGISTERS;
 #pragma pack()
 
diff --git a/UefiCpuPkg/Library/CpuExceptionHandlerLib/RiscV64/SupervisorTrapHandler.S b/UefiCpuPkg/Library/CpuExceptionHandlerLib/RiscV64/SupervisorTrapHandler.S
index 649c4c5bec..e294954f6d 100644
--- a/UefiCpuPkg/Library/CpuExceptionHandlerLib/RiscV64/SupervisorTrapHandler.S
+++ b/UefiCpuPkg/Library/CpuExceptionHandlerLib/RiscV64/SupervisorTrapHandler.S
@@ -20,14 +20,12 @@ SupervisorModeTrap:
   sd    t0, SMODE_TRAP_REGS_OFFSET(t0)(sp)
 
   csrr  t0, CSR_SSTATUS
-  and   t0, t0, (SSTATUS_SIE | SSTATUS_SPIE)
   sd    t0, SMODE_TRAP_REGS_OFFSET(sstatus)(sp)
   csrr  t0, CSR_SEPC
   sd    t0, SMODE_TRAP_REGS_OFFSET(sepc)(sp)
-  csrr  t0, CSR_SIE
-  sd    t0, SMODE_TRAP_REGS_OFFSET(sie)(sp)
   ld    t0, SMODE_TRAP_REGS_OFFSET(t0)(sp)
 
+  sd    zero, SMODE_TRAP_REGS_OFFSET(zero)(sp)
   sd    ra, SMODE_TRAP_REGS_OFFSET(ra)(sp)
   sd    gp, SMODE_TRAP_REGS_OFFSET(gp)(sp)
   sd    tp, SMODE_TRAP_REGS_OFFSET(tp)(sp)
@@ -59,6 +57,7 @@ SupervisorModeTrap:
   sd    t6, SMODE_TRAP_REGS_OFFSET(t6)(sp)
 
   /* Call to Supervisor mode trap handler in CpuExceptionHandlerLib.c */
+  mv    a0, sp
   call  RiscVSupervisorModeTrapHandler
 
   /* Restore all general regisers except SP */
@@ -66,6 +65,7 @@ SupervisorModeTrap:
   ld    gp, SMODE_TRAP_REGS_OFFSET(gp)(sp)
   ld    tp, SMODE_TRAP_REGS_OFFSET(tp)(sp)
   ld    t2, SMODE_TRAP_REGS_OFFSET(t2)(sp)
+  ld    t1, SMODE_TRAP_REGS_OFFSET(t1)(sp)
   ld    s0, SMODE_TRAP_REGS_OFFSET(s0)(sp)
   ld    s1, SMODE_TRAP_REGS_OFFSET(s1)(sp)
   ld    a0, SMODE_TRAP_REGS_OFFSET(a0)(sp)
@@ -93,13 +93,8 @@ SupervisorModeTrap:
 
   ld    t0, SMODE_TRAP_REGS_OFFSET(sepc)(sp)
   csrw  CSR_SEPC, t0
-  ld    t0, SMODE_TRAP_REGS_OFFSET(sie)(sp)
-  csrw  CSR_SIE, t0
-  csrr  t0, CSR_SSTATUS
-  ld    t1, SMODE_TRAP_REGS_OFFSET(sstatus)(sp)
-  or    t0, t0, t1
+  ld    t0, SMODE_TRAP_REGS_OFFSET(sstatus)(sp)
   csrw  CSR_SSTATUS, t0
-  ld    t1, SMODE_TRAP_REGS_OFFSET(t1)(sp)
   ld    t0, SMODE_TRAP_REGS_OFFSET(t0)(sp)
   addi  sp, sp, SMODE_TRAP_REGS_SIZE
   sret
-- 
2.25.1

